package Compiler;

import java_cup.runtime.*;
import ir.ast.*;
import java.util.*;

/*	keywords	*/
terminal BOOL_TYPE, FLOAT_TYPE, INT_TYPE, VOID_TYPE, BREAK, CLASS_DECL, CONT, ELSE, EXTERN, FOR, IF, RET, WHILE; 

/*	assign operators	*/
terminal ASSIGN, ASSIGNP, ASSIGNM;

/*	arith operators	*/
terminal SEMI, DOC, COMMA, PLUS, MINUS, TIMES, DIV, MOD, UMINUS;

/*	eq operators	*/
terminal EQUAL, DISTINCT;

/*	rel operators	*/
terminal SMALLER, BIGGER, LTOE, GTOE;   

/*	cond operators	*/
terminal AND, OR, NOT;

/*		*/
terminal  LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET;
terminal Integer INTNUMBER;
terminal Float REALNUMBER;
terminal Boolean BOOL_LITERAL;
terminal String ID;

non terminal  return_st;

non terminal Program program;
non terminal ClassDecl class_decl;
non terminal List<ClassDecl> class_decl_list;
non terminal FieldDecl field_decl;
non terminal List<FieldDecl> field_decl_list;
non terminal MethodDecl method_decl;
non terminal List<MethodDecl> method_decl_list;
non terminal String type;
non terminal List<IdDecl> id_name_list;
non terminal IdDecl id_name;
non terminal List<ParamDecl> params_decl_list;
non terminal ParamDecl params_decl;
non terminal BodyDecl  body;
non terminal Block block;
non terminal Statement statement;
non terminal List<Statement> statement_list;	
non terminal MethodCallStmt method_call_stmt;
non terminal MethodCall method_call;
non terminal ir.ast.Location location;
non terminal Expression expr;
non terminal Literal literal;
non terminal List<Expression> params;
non terminal String attribute_access;
non terminal List<String> attribute_access_list;
non terminal AssignOpType assign_op;

precedence left LBRACE, RBRACE;
precedence left LPAREN,RPAREN;
precedence left LBRACKET, RBRACKET;
precedence left AND ;
precedence left OR ;
precedence nonassoc SMALLER,BIGGER,LTOE,GTOE,EQUAL,DISTINCT; 
precedence left PLUS, MINUS;
precedence left TIMES,DIV,MOD;
precedence left NOT, UMINUS;
precedence left ELSE;

start with program;
//Inicializar type al principio del programa
program             	::= class_decl_list:cdN1                                        	{: RESULT = new Program(cdN1); :}
						;

class_decl_list        	::= class_decl_list:cD1 class_decl:cD2		                        {: cD1.add(cD2); RESULT=cD1;:}
						| class_decl:cD3                                                	{:List<ClassDecl> classDeclL=new LinkedList<ClassDecl>();classDeclL.add(cD3)
																                         	; RESULT=classDeclL;:}
						;

class_decl          	::= CLASS_DECL ID:i1 LBRACE field_decl_list:fd1 method_decl_list:md1 RBRACE {:RESULT = new ClassDecl(i1,fd1,md1);:}
						| CLASS_DECL ID:i1 LBRACE method_decl_list:md1 RBRACE           	{:RESULT = new ClassDecl(i1,new LinkedList<FieldDecl>(),md1);:} 
						| CLASS_DECL ID:i1 LBRACE field_decl_list:fd1 RBRACE            	{:RESULT = new ClassDecl(i1,fd1,new LinkedList<MethodDecl>());:}
						| CLASS_DECL ID:i1 LBRACE RBRACE                                	{:RESULT = new ClassDecl(i1,new LinkedList<FieldDecl>(),new LinkedList<MethodDecl>());:}
						;

field_decl_list    		::= field_decl_list:fdl1 field_decl:fd                          	{:fdl1.add(fd);RESULT=fdl1;:}
						|  field_decl:fd                                                	{:List<FieldDecl> fieldDeclL = new LinkedList<FieldDecl>();fieldDeclL.add(fd);
																                          	RESULT = fieldDeclL;:}
						;

field_decl          	::= type:t1 id_name_list:af1 SEMI 		                        	{:RESULT = new FieldDecl(t1,af1);:}
						;

id_name_list			::= id_name_list:inl1 COMMA id_name:in1                         	{:inl1.add(in1);RESULT=inl1;:}  
						| id_name:in2							                        	{:List<IdDecl> names = new LinkedList<IdDecl>();names.add(in2);RESULT=names;:}
						;
 
id_name		      		::= ID:i5 LBRACKET INTNUMBER:il1 RBRACKET                       	{:RESULT = new ArrayIdDecl(i5,il1);:}
						| ID:i4 								                        	{:RESULT = new IdDecl(i4);:}
						;

method_decl_list		::= method_decl_list:mdl1 method_decl:md		                	{:mdl1.add(md); RESULT = mdl1;:}
						| method_decl
						;

method_decl         	::= type:t1 ID:i7 LPAREN RPAREN body:bo1                        	{:RESULT = new MethodDecl(t1,i7,bo1);:}
						| type:t1 ID:i7 LPAREN params_decl_list:pdl1 RPAREN body:bo1    	{:RESULT = new MethodDecl(t1,i7,pdl1,bo1);:}
						; 

params_decl_list		::= params_decl_list:pdl1 COMMA params_decl:pd1 			    	{:pdl1.add(pd1); RESULT = pdl1;:}
						| params_decl:pd2 											    	{:List<ParamDecl> params = new LinkedList<ParamDecl>();
																							params.add(pd2);RESULT=params;:}
						;

params_decl 			::= type:t3 ID:i8 													{:RESULT = new ParamDecl(t3,i8);:}
						;

body 					::= block:bl1 														{:RESULT = new BodyDecl(bl1);:}
						| EXTERN SEMI 														{:RESULT = new BodyDecl(true);:}
						;

block					::= LBRACE field_decl_list:fdl3  statement_list:s1 RBRACE       	{:RESULT = new Block(0,fdl3,s1);:}
						| LBRACE field_decl_list:fdl4 RBRACE 								{:RESULT = new Block(0,fdl4,new LinkedList<Statement>());:}
						| LBRACE statement_list:s1 RBRACE 									{:RESULT = new Block(0,new LinkedList<FieldDecl>(),s1);:}
						| LBRACE RBRACE 													{:RESULT = new Block(0);:}
						;

type					::= INT_TYPE 														{:RESULT = "INT";:}
						| FLOAT_TYPE 														{:RESULT = "FLOAT";:}
						| BOOL_TYPE 														{:RESULT = "BOOLEAN";:}
						| ID:i10 															{://ver	
																								try{
																									Type.add(i10);RESULT = i10;}
																								catch(Exception e){
																							
																								}
																							:} 
 						| VOID_TYPE 														{:RESULT = "VOID";:}
						;

statement_list			::= statement_list:sL1 statement:s1									{:sL1.add(s1);RESULT = sL1;:}
						| statement:s1 														{:List<Statement> stmt = new LinkedList<Statement>();stmt.add(s1);RESULT = stmt;:}
						;

statement				::=  location:l1 assign_op:ao1 expr:e1 SEMI							{:RESULT = new AssignStmt(l1,ao1,e1);:}
						| method_call:mc1 SEMI												{:RESULT = new MethodCallStmt(mc1);:}
						| IF LPAREN expr:e2 RPAREN statement:s2 							{:RESULT = new IfThenStmt(e2,s2);:}
						| IF LPAREN expr:e2 RPAREN statement:s2 ELSE statement:s3       	{:RESULT = new IfThenElseStmt(e2,s2,s3);:}
						| FOR ID:i11 ASSIGN expr:e3 COMMA expr:e4 statement:s4          	{:RESULT = new ForStmt(i11,e3,e4,s4);:}
						| WHILE expr:e3 statement:s5										{:RESULT = new WhileStmt(e3,s5);:}
						| return_st														
						| BREAK SEMI														{:RESULT = new BreakStmt();:}
						| CONT SEMI															{:RESULT = new ContinueStmt();:}
						| SEMI															
					 	| block:bl2 														{:RESULT = new Block(0);:}
					 	;

return_st 				::= RET expr:e1 SEMI												{:RESULT = new ReturnStmt(e1);:}
						| RET SEMI 															{:RESULT = new ReturnVoidStmt();:}
						;

assign_op  				::= ASSIGN 															{:RESULT = AssignOpType.ASSIGN;:}
						| ASSIGNP 															{:RESULT = AssignOpType.INCREMENT;:}
						| ASSIGNM 															{:RESULT = AssignOpType.DECREMENT;:}
						;



method_call         	::= ID:id1 attribute_access_list:amc11 LPAREN params:p2 RPAREN		{:amc11.add(id1);RESULT = new MethodCall(amc11,p2);:}
						| ID:id2 attribute_access_list:amc11 LPAREN RPAREN					{:amc11.add(id2);List<Expression> params = new LinkedList<Expression>();RESULT = new MethodCall(amc11,params);:}
						| ID:id3 LPAREN params:p2 RPAREN									{:List<String> ids = new LinkedList<String>();ids.add(id3); RESULT = new MethodCall(ids,p2);:}
						| ID:id4 LPAREN  RPAREN 											{:List<String> ids = new LinkedList<String>();ids.add(id4); List<Expression> params = new LinkedList<Expression>(); RESULT = new MethodCall(ids,params);:}
						; 

params					::= params:p1 COMMA expr:e1										    {:p1.add(e1);RESULT=p1;:}
						| expr:e2 															{:List<Expression> exprList = new LinkedList<Expression>();exprList.add(e2);RESULT = exprList;:}
						;

attribute_access_list 	::= attribute_access_list:aal1 attribute_access:aa1					{:aal1.add(aa1);RESULT=aal1;:}
						| attribute_access:aa2												{:List<String> ids = new LinkedList<String>();ids.add(aa2);RESULT = ids;:}
						;

attribute_access		::= DOC ID:i1 														{:RESULT = new String(i1);:}
						;

location 				::= ID:id1 															{:RESULT = new VarLocation(id1);:}
						| ID:id2 attribute_access_list:acl2 								{:acl2.add(id2); RESULT = new AttributeLocation(acl2);:}
						| ID:id3 LBRACKET expr:e1 RBRACKET								    {:List<String> ids = new LinkedList<String>(); ids.add(id3); RESULT = new ArrayLocation(ids,e1);:}
						| ID:id4 attribute_access_list:acl2 LBRACKET expr:e2 RBRACKET		{:acl2.add(id4);RESULT = new AttributeArrayLocation(acl2,e2);:}
						;

expr					::= location:l2														{:RESULT = l2;:}													
						| method_call:mc2													{:RESULT = mc2;:}
						| literal:li1														{:RESULT = li1;:}
						| LPAREN expr:e4 RPAREN												{:RESULT = e4;:}
						| expr:e4 AND:op expr:e5											{:RESULT = new LogicalBinOp(e4,BinOpType.AND,e5);:}
						| expr:e4 OR:op expr:e5												{:RESULT = new LogicalBinOp(e4,BinOpType.OR,e5);:}
						| expr:e4 PLUS:op expr:e5 											{:RESULT = new ArithmeticBinOp(e4,BinOpType.PLUS,e5);:}
						| expr:e4 MINUS:op expr:e5 											{:RESULT = new ArithmeticBinOp(e4,BinOpType.MINUS,e5);:}
						| expr:e4 TIMES:op expr:e5 											{:RESULT = new ArithmeticBinOp(e4,BinOpType.TIMES,e5);:}
						| expr:e4 DIV:op expr:e5											{:RESULT = new ArithmeticBinOp(e4,BinOpType.DIV,e5);:}
						| expr:e4 MOD:op expr:e5											{:RESULT = new ArithmeticBinOp(e4,BinOpType.MOD,e5);:}
						| expr:e4 SMALLER:op expr:e5										{:RESULT = new RelationalBinOp(e4,BinOpType.SMALL,e5);:}
						| expr:e4 BIGGER:op expr:e5											{:RESULT = new RelationalBinOp(e4,BinOpType.BIGGER,e5);:}
						| expr:e4 LTOE:op expr:e5						   					{:RESULT = new RelationalBinOp(e4,BinOpType.LTOE,e5);:}
						| expr:e4 GTOE expr:e5												{:RESULT = new RelationalBinOp(e4,BinOpType.GTOE,e5);:}
						| expr:e4 EQUAL expr:e5												{:RESULT = new EqBinOp(e4,BinOpType.EQUAL,e5);:}
						| expr:e4 DISTINCT expr:e5											{:RESULT = new EqBinOp(e4,BinOpType.DISTINCT,e5);:}
						| MINUS:op expr:e6 													{:RESULT = new ArithmeticUnaryOp(UnaryOpType.MINUS,e6);:}	 %prec UMINUS	
						| NOT:op expr:e7													{:RESULT = new LogicalUnaryOp(UnaryOpType.NOT,e7);:}
						;

literal  				::= INTNUMBER:val													{:RESULT = new IntLiteral(val);:}								
						| REALNUMBER:val 													{:RESULT = new FloatLiteral(val);:}
						| BOOL_LITERAL:val 													{:RESULT = new BooleanLiteral(val);:}
						;
