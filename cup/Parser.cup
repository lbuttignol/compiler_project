package Example;

import java_cup.runtime.*;
import Example.Parser.Expr;

parser code {:
    public static abstract class Expr {
	public abstract int eval();
	public abstract Location right();
	public abstract Location left();
	static class BinExpr extends Expr {
	    Expr l,r;
	    int s;
	    BinExpr(Expr l, int sym,Expr r){
		this.l=l;
		this.r=r;
		this.s=sym;
	    }
	    public int eval(){
		if (s==sym.PLUS) return l.eval() + r.eval();
		else return l.eval() * r.eval();
	    }
	    public Location left() { return l.left(); }
	    public Location right() {return r.right(); }
	}
	static class Const extends Expr {
	    Location l,r;
	    Integer value;
	    Const(Location l,Integer i,Location r){
		this.l=l;
		this.r=r;
		this.value = i;
	    }
	    public int eval(){ return value;  }
	    public Location left() { return l; }
	    public Location right() {return r; }
	}
    }
    public static void main(String args[]) throws Exception {
	ComplexSymbolFactory sf = new ComplexSymbolFactory();
	if (args.length==0) new Parser(new Scanner(System.in,sf),sf).parse();
	else new Parser(new Scanner(new java.io.FileInputStream(args[0]),sf),sf).parse();
    }

    public void syntax_error(Symbol sym){ 
	// Mute legacy Error Printing
    }
:}

/*	keywords	*/
terminal BOOL_TYPE, FLOAT_TYPE, INT_TYPE, VOID_TYPE, BREAK, CLASS_DECL, CONT, ELSE, EXTERN, BOOL_LITERAL, FOR, IF, RET, WHILE; 

/*	assign operators	*/
terminal ASSIGN, ASSIGNP, ASSIGNM;

/*	arith operators	*/
terminal SEMI, DOC, COMMA, PLUS, MINUS, TIMES, DIV, MOD, MINUSMINUS, PLUSPLUS;

/*	eq operators	*/
terminal EQUAL, DISTINCT;

/*	rel operators	*/
terminal SMALLER, BIGGER, LTOE, GTOE;   // 

/*	cond operators	*/
terminal AND, OR, NOT;

/*		*/
terminal  LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET;
terminal Integer INTNUMBER;
terminal REALNUMBER, ID;

non terminal program, class_decl, class_decl_list, field_decl, method_decl, aux_method_decl, method_decl_list,
			 body, block, type, statement, statement_list, assign_op, method_call, attribute_access_list, attribute_access,params,
			 location, expr, bin_op, arith_op, rel_op, eq_op, cond_op, literal, field_decl_list,id_name_list,id_name, return_st;

precedence left LBRACE, RBRACE;
precedence left LPAREN,RPAREN;
precedence left LBRACKET, RBRACKET;
precedence left SMALLER,BIGGER,LTOE,GTOE,AND,OR,EQUAL,DISTINCT; 
precedence left PLUS,MINUS;
precedence left TIMES,DIV,MOD;
precedence right NOT;
precedence left ELSE;

start with program;

program             	::= class_decl_list:cdN1 ;

class_decl_list        	::= class_decl_list:cD1 class_decl:cD2
						| class_decl:cD3 ;

class_decl          	::= CLASS_DECL ID:i1 LBRACE field_decl_list:fd1 method_decl:md1 RBRACE
						| CLASS_DECL ID:i1 LBRACE method_decl:md1 RBRACE
						| CLASS_DECL ID:i1 LBRACE field_decl_list:fd1 RBRACE
						| CLASS_DECL ID:i1 LBRACE RBRACE ;

field_decl_list    		::= field_decl_list field_decl 
						|  field_decl ;

field_decl          	::= type:t1 id_name_list:af1 SEMI ;

id_name_list			::= id_name_list COMMA id_name
						| id_name ;
 
id_name		      		::= ID:i5 LBRACKET INTNUMBER:il1 RBRACKET
						| ID:i4 ;

method_decl         	::= type:t1 ID:i7 LPAREN RPAREN body:bo1
						| type:t1 ID:i7 LPAREN aux_method_decl RPAREN body:bo1  
						| type:t1 ID:i7 LPAREN method_decl_list RPAREN body:bo1 ; 

aux_method_decl     	::= type:t2 ID:i8 ;

method_decl_list		::= method_decl_list COMMA aux_method_decl
						| aux_method_decl ;

body 					::= block:bl1 
						| EXTERN SEMI ;

block					::= LBRACE field_decl_list:fdl3  statement_list:s1 RBRACE
						| LBRACE field_decl_list RBRACE
						| LBRACE statement_list:s1 RBRACE
						| LBRACE RBRACE ;

type					::= INT_TYPE 
						| FLOAT_TYPE 
						| BOOL_TYPE 
						| ID:i10 
						| VOID_TYPE ;

statement_list			::= statement_list:sL1 statement:s1
						| statement:s1 ;

statement				::=  location:l1 assign_op:ao1 expr:e1 SEMI
						| method_call:mc1 SEMI
						| IF LPAREN expr:e2 RPAREN statement:s2 
						| IF LPAREN expr:e2 RPAREN statement:s2 ELSE statement:s3
						| FOR ID:i11 ASSIGN expr:e3 COMMA method_decl_list
						| WHILE expr:e3 statement
						| return_st
						| BREAK SEMI
						| CONT SEMI
						| SEMI
						| expr PLUSPLUS SEMI
						| expr MINUSMINUS SEMI
					 	| block:bl2 ;

return_st 				::= RET expr SEMI
						| RET SEMI ;

assign_op  				::= ASSIGN 
						| ASSIGNP 
						| ASSIGNM ;

method_call         	::= ID attribute_access_list:amc11 LPAREN params:p2 RPAREN
						| ID attribute_access_list:amc11 LPAREN RPAREN
						| ID LPAREN params:p2 RPAREN
						| ID LPAREN  RPAREN ; 

params					::= params COMMA expr
						| expr ;

attribute_access_list 	::= attribute_access_list attribute_access
						| attribute_access ;

attribute_access		::= DOC ID ;

location 				::= ID 
						| ID attribute_access_list:amc13 
						| ID LBRACKET expr RBRACKET
						| ID attribute_access_list LBRACKET expr RBRACKET;

expr					::= location:l2
						| method_call:mc2
						| literal:li1
						| expr:e4 bin_op:bo2 expr:e5
						| MINUS expr:e6
						| NOT expr:e7
						| LPAREN expr:e8 RPAREN ;

bin_op  				::= arith_op:ao2 
						| rel_op:ro1 
						| eq_op:eo1 
						| cond_op:co1 ;

arith_op 				::= PLUS 
						| MINUS 
						| TIMES 
						| DIV 
						| MOD ;

rel_op   				::= SMALLER 
						| BIGGER 
						| LTOE 
						| GTOE ;

eq_op    				::= EQUAL 
						| DISTINCT ;

cond_op  				::= AND 
						| OR ;

literal  				::= INTNUMBER 
						| REALNUMBER 
						| BOOL_LITERAL ;
