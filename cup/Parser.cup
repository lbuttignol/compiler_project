
package Compiler;

import java_cup.runtime.*;
import ir.ast.*;
import java.util.*;

/*	keywords	*/
terminal BOOL_TYPE, FLOAT_TYPE, INT_TYPE, VOID_TYPE, BREAK, CLASS_DECL, CONT, ELSE, EXTERN, FOR, IF, RET, WHILE; 

/*	assign operators	*/
terminal ASSIGN, ASSIGNP, ASSIGNM;

/*	arith operators	*/
terminal SEMI, DOC, COMMA, PLUS, MINUS, TIMES, DIV, MOD, UMINUS;

/*	eq operators	*/
terminal EQUAL, DISTINCT;

/*	rel operators	*/
terminal SMALLER, BIGGER, LTOE, GTOE;   

/*	cond operators	*/
terminal AND, OR, NOT;

/*		*/
terminal  LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET;
terminal Integer INTNUMBER;
terminal Float REALNUMBER;
terminal Boolean BOOL_LITERAL;
terminal String ID;

non terminal  return_st;

non terminal Program program;
non terminal ClassDecl class_decl;
non terminal List<ClassDecl> class_decl_list;
non terminal FieldDecl field_decl;
non terminal List<FieldDecl> field_decl_list;
non terminal MethodDecl method_decl;
non terminal List<MethodDecl> method_decl_list;
non terminal String type;
non terminal List<IdDecl> id_name_list;
non terminal IdDecl id_name;
non terminal List<ParamDecl> params_decl_list;
non terminal ParamDecl params_decl;
non terminal BodyDecl  body;
non terminal Block block;
non terminal Statement statement;
non terminal List<Statement> statement_list;	
non terminal MethodCallStmt method_call_stmt;
non terminal MethodCall method_call;
non terminal ir.ast.Location location;
non terminal Expression expr;
non terminal Literal literal;
non terminal List<Expression> params;
non terminal String attribute_access;
non terminal List<String> attribute_access_list;
non terminal AssignOpType assign_op;

precedence left LBRACE, RBRACE;
precedence left LPAREN,RPAREN;
precedence left LBRACKET, RBRACKET;
precedence left AND ;
precedence left OR ;
precedence nonassoc SMALLER,BIGGER,LTOE,GTOE,EQUAL,DISTINCT; 
precedence left PLUS, MINUS;
precedence left TIMES,DIV,MOD;
precedence left NOT, UMINUS;
precedence left ELSE;

start with program;

//Inicializar type al principio del programa
program             	::= class_decl_list:classDeclList                                   		{: RESULT = new Program(classDeclList); :}
						;

class_decl_list        	::= class_decl_list:classDeclList class_decl:classDecl		        		{: classDeclList.add(classDecl); RESULT = classDeclList; :}
						| class_decl:classDecl                                             			{: List<ClassDecl> classDeclList=new LinkedList<ClassDecl>();classDeclList.add(classDecl)
																                         			; RESULT=classDeclList;:}

						;

class_decl          	::= CLASS_DECL ID:id LBRACE field_decl_list:fieldDeclL method_decl_list:methodDeclL RBRACE  {: RESULT = new ClassDecl(id,fieldDeclL,methodDeclL); :}
						| CLASS_DECL ID:id LBRACE method_decl_list:methodDeclL RBRACE           					{: RESULT = new ClassDecl(id,new LinkedList<FieldDecl>(),methodDeclL); :} 
						| CLASS_DECL ID:id LBRACE field_decl_list:fieldDeclL RBRACE            						{: RESULT = new ClassDecl(id,fieldDeclL,new LinkedList<MethodDecl>());:}
						| CLASS_DECL ID:id LBRACE RBRACE                                							{: RESULT = new ClassDecl(id,new LinkedList<FieldDecl>(),new LinkedList<MethodDecl>());:}
						;

field_decl_list    		::= field_decl_list:fieldDeclL field_decl:fieldDecl                          				{: fieldDeclL.add(fieldDecl);RESULT=fieldDeclL;:}
						|  field_decl:fieldDecl                                             					   	{: List<FieldDecl> fieldDeclL = new LinkedList<FieldDecl>();fieldDeclL.add(fieldDecl);
																                          							   RESULT = fieldDeclL;:}
						;

field_decl          	::= type:type id_name_list:idList SEMI 		                     			{: RESULT = new FieldDecl(type,idList);:}
						;

id_name_list			::= id_name_list:idList COMMA id_name:id                         			{: idList.add(id);RESULT=idList;:}  
						| id_name:id							                        			{: List<IdDecl> names = new LinkedList<IdDecl>();names.add(id);RESULT=names;:}
						;
 
id_name		      		::= ID:id LBRACKET INTNUMBER:number RBRACKET                       			{: RESULT = new ArrayIdDecl(id,number);:}
						| ID:id 								                        			{: RESULT = new IdDecl(id);:}
						;

method_decl_list		::= method_decl_list:metnodDeclList method_decl:methodDecl		   			{: metnodDeclList.add(methodDecl); RESULT = metnodDeclList;:}
						| method_decl:methodDecl													{: List<MethodDecl> methodDeclList = new LinkedList<MethodDecl>(); methodDeclList.add(methodDecl);
																							 		  RESULT = methodDeclList;:}
						;

method_decl         	::= type:type ID:id LPAREN RPAREN body:body                        			{: RESULT = new MethodDecl(type,id,body);:}
						| type:type ID:id LPAREN params_decl_list:paramsDeclList RPAREN body:body   {: RESULT = new MethodDecl(type,id,paramsDeclList,body);:}
						; 

params_decl_list		::= params_decl_list:paramsDeclList COMMA params_decl:paramsDecl   			{:paramsDeclList.add(paramsDecl); RESULT = paramsDeclList;:}
						| params_decl:paramsDecl													{:List<ParamDecl> params = new LinkedList<ParamDecl>();
																									 params.add(paramsDecl); RESULT=params; :}
						;

params_decl 			::= type:type ID:id 														{:RESULT = new ParamDecl(type,id);:}
						;

body 					::= block:block 															{:RESULT = new BodyDecl(block);:}
						| EXTERN SEMI 																{:RESULT = new BodyDecl(true);:}
						;

block					::= LBRACE field_decl_list:fieldDeclL  statement_list:stmtList RBRACE   	{:RESULT = new Block(0,fieldDeclL,stmtList);:}
						| LBRACE field_decl_list:fieldDeclL RBRACE 									{:RESULT = new Block(0,fieldDeclL,new LinkedList<Statement>());:}
						| LBRACE statement_list:stmtList RBRACE 									{:RESULT = new Block(0,new LinkedList<FieldDecl>(),stmtList);:}
						| LBRACE RBRACE 													   		{:RESULT = new Block(0);:}
						;

type					::= INT_TYPE 																{:RESULT = "INT";:}
						| FLOAT_TYPE 																{:RESULT = "FLOAT";:}
						| BOOL_TYPE 																{:RESULT = "BOOLEAN";:}
								| ID:id 															{://ver	
																										try{
																											Type.add(id);RESULT = id;}
																										catch(Exception e){
																									
																										}
																									:} 
 						| VOID_TYPE 																{:RESULT = "VOID";:}
						;

statement_list			::= statement_list:stmtList statement:stmt									{:stmtList.add(stmt);RESULT = stmtList;:}
						| statement:stmt															{:List<Statement> statement = new LinkedList<Statement>();statement.add(stmt);RESULT = statement;:}
						;

statement				::=  location:loc assign_op:assignOp expr:expr SEMI							{:RESULT = new AssignStmt(loc,assignOp,expr);:}
						| method_call:methodCall SEMI												{:RESULT = new MethodCallStmt(methodCall);:}
						| IF LPAREN expr:expr RPAREN statement:stmt 								{:RESULT = new IfThenStmt(expr,stmt);:}
						| IF LPAREN expr:expr RPAREN statement:stmtIf ELSE statement:stmtElse       {:RESULT = new IfThenElseStmt(expr,stmtIf,stmtElse);:}
						| FOR ID:id ASSIGN expr:exprFor COMMA expr:exprTo statement:stmt          	{:RESULT = new ForStmt(id,exprFor,exprTo,stmt);:}
						| WHILE expr:e3 statement:s5												{:RESULT = new WhileStmt(e3,s5);:}
						| return_st														
						| BREAK SEMI																{:RESULT = new BreakStmt();:}
						| CONT SEMI																	{:RESULT = new ContinueStmt();:}
						| SEMI															
					 	| block:block 																{:RESULT = new Block(0);:}
					 	;


return_st 				::= RET expr:expre SEMI														{:RESULT = new ReturnStmt(expre);:}
						| RET SEMI 																	{:RESULT = new ReturnVoidStmt();:}

						;

assign_op  				::= ASSIGN 																	{:RESULT = AssignOpType.ASSIGN;:}
						| ASSIGNP 																	{:RESULT = AssignOpType.INCREMENT;:}
						| ASSIGNM 																	{:RESULT = AssignOpType.DECREMENT;:}
						;



method_call         	::= ID:id attribute_access_list:attributeAccessL LPAREN params:params RPAREN	{:attributeAccessL.add(id);RESULT = new MethodCall(attributeAccessL,params);:}
						| ID:id attribute_access_list:attributeAccessL LPAREN RPAREN					{:attributeAccessL.add(id);List<Expression> params = new LinkedList<Expression>();RESULT = new MethodCall(attributeAccessL,params);:}
						| ID:id LPAREN params:params RPAREN												{:List<String> ids = new LinkedList<String>();ids.add(id); RESULT = new MethodCall(ids,params);:}
						| ID:id LPAREN  RPAREN 															{:List<String> ids = new LinkedList<String>();ids.add(id); List<Expression> params = new LinkedList<Expression>(); RESULT = new MethodCall(ids,params);:}
						; 

params					::= params:params COMMA expr:expr											    {:params.add(expr);RESULT=params;:}
						| expr:expr 																	{:List<Expression> exprList = new LinkedList<Expression>();exprList.add(expr);RESULT = exprList;:}
						;

attribute_access_list 	::= attribute_access_list:aal1 attribute_access:aa1								{:aal1.add(aa1);RESULT=aal1;:}
						| attribute_access:aa2															{:List<String> ids = new LinkedList<String>();ids.add(aa2);RESULT = ids;:}
						;

attribute_access		::= DOC ID:id 																	{:RESULT = new String(id);:}
						;

location 				::= ID:id 																		{:RESULT = new VarLocation(id);:}
						| ID:id attribute_access_list:attributeAccessL 									{:attributeAccessL.add(id); RESULT = new AttributeLocation(attributeAccessL);:}
						| ID:id LBRACKET expr:expr RBRACKET								  				{:List<String> ids = new LinkedList<String>(); ids.add(id); RESULT = new ArrayLocation(ids,expr);:}
						| ID:id attribute_access_list:attributeAccessL LBRACKET expr:expr RBRACKET		{:attributeAccessL.add(id);RESULT = new AttributeArrayLocation(attributeAccessL,expr);:}
						;

expr					::= location:loc																{:RESULT = loc;:}													
						| method_call:methodCall														{:RESULT = methodCall;:}
						| literal:lit																	{:RESULT = lit;:}
						| LPAREN expr:expr RPAREN														{:RESULT = expr;:}
						| expr:exprLeft AND:op expr:exprRigth											{:RESULT = new LogicalBinOp(exprLeft,BinOpType.AND,exprRigth);:}
						| expr:exprLeft OR:op expr:exprRigth											{:RESULT = new LogicalBinOp(exprLeft,BinOpType.OR,exprRigth);:}
						| expr:exprLeft PLUS:op expr:exprRigth 											{:RESULT = new ArithmeticBinOp(exprLeft,BinOpType.PLUS,exprRigth);:}
						| expr:exprLeft MINUS:op expr:exprRigth 										{:RESULT = new ArithmeticBinOp(exprLeft,BinOpType.MINUS,exprRigth);:}
						| expr:exprLeft TIMES:op expr:exprRigth 										{:RESULT = new ArithmeticBinOp(exprLeft,BinOpType.TIMES,exprRigth);:}
						| expr:exprLeft DIV:op expr:exprRigth											{:RESULT = new ArithmeticBinOp(exprLeft,BinOpType.DIV,exprRigth);:}
						| expr:exprLeft MOD:op expr:exprRigth											{:RESULT = new ArithmeticBinOp(exprLeft,BinOpType.MOD,exprRigth);:}
						| expr:exprLeft SMALLER:op expr:exprRigth										{:RESULT = new RelationalBinOp(exprLeft,BinOpType.SMALL,exprRigth);:}
						| expr:exprLeft BIGGER:op expr:exprRigth										{:RESULT = new RelationalBinOp(exprLeft,BinOpType.BIGGER,exprRigth);:}
						| expr:exprLeft LTOE:op expr:exprRigth						   					{:RESULT = new RelationalBinOp(exprLeft,BinOpType.LTOE,exprRigth);:}
						| expr:exprLeft GTOE expr:exprRigth												{:RESULT = new RelationalBinOp(exprLeft,BinOpType.GTOE,exprRigth);:}
						| expr:exprLeft EQUAL expr:exprRigth											{:RESULT = new EqBinOp(exprLeft,BinOpType.EQUAL,exprRigth);:}
						| expr:exprLeft DISTINCT expr:exprRigth											{:RESULT = new EqBinOp(exprLeft,BinOpType.DISTINCT,exprRigth);:}
						| MINUS:op expr:expr 															{:RESULT = new ArithmeticUnaryOp(UnaryOpType.MINUS,expr);:}	 %prec UMINUS	
						| NOT:op expr:expr																{:RESULT = new LogicalUnaryOp(UnaryOpType.NOT,expr);:}
						;

literal  				::= INTNUMBER:val														{:RESULT = new IntLiteral(val);:}								
						| REALNUMBER:val 														{:RESULT = new FloatLiteral(val);:}
						| BOOL_LITERAL:val 														{:RESULT = new BooleanLiteral(val);:}

						;
